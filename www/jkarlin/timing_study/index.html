  <!DOCTYPE html>
  <html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='plotly.js'></script>
    <script src='regression.js'></script>
  </head>

  <body>
    <p>This site downloads opaque resources of various sizes and plots the distributions of the time between resource start and end from the network. This gives us an idea of how accurate network timing attacks may be.</p>

    <div id="status">Gathering samples...</div>
    <div id="plot" style="width:900px;height:400px;"></div>

    <script>

      const kMaxPow = 8;
      const kSamplesPerSize = 40;
      const kWarmUpCount = 20;

      performance.setResourceTimingBufferSize(kSamplesPerSize * (kMaxPow + 1) + kWarmUpCount );

      // Creates a link rel=prefetch and times how long the resource load takes.
      let resourceCount = 0;
      async function timeResourceLoad(size) {
        var link = document.createElement('link');
        link.rel = "prefetch";

        return new Promise(function(resolve, reject) {
          let url = "https://cr2.kungfoo.net/jkarlin/timing/size.php?size=" + size + '?count=' + resourceCount++;
          link.onerror = function() {
            console.log("OnError");
            let perf_entry = window.performance.getEntriesByName(url, 'resource')[0];
            resolve(perf_entry.responseEnd - perf_entry.startTime);
          }
          link.onload = function() {
            let perf_entry = window.performance.getEntriesByName(url, 'resource')[0];
            resolve(perf_entry.responseEnd - perf_entry.startTime);
          }

          link.href = url;
          document.body.appendChild(link);
        });
      }

      function standardDeviation(values){
        let avg = mean(values);

        let squareDiffs = values.map(function(value){
          var diff = value - avg;
          var sqrDiff = diff * diff;
          return sqrDiff;
        });

        let avgSquareDiff = mean(squareDiffs);

        let stdDev = Math.sqrt(avgSquareDiff);
        return stdDev;
      }

      function sampleStandardError(values) {
       return sampleStandardDeviation(values) / Math.sqrt(values.length) 
      }

      function sampleStandardDeviation(values){
        let avg = mean(values);
        
        let sum_diffs = 0;
        for (i of values) {
         let diff = i - avg;
         sum_diffs += diff * diff;
        }
        
        return Math.sqrt(sum_diffs / (values.length - 1))
      }      
      
      // returns slope, intercept and r-square of the line
      // from: http://bl.ocks.org/benvandyke/8459843
      function leastSquares(xSeries, ySeries) {
        var reduceSumFunc = function(prev, cur) { return prev + cur; };

        var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
        var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;

        var ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
          .reduce(reduceSumFunc);

        var ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
          .reduce(reduceSumFunc);

        var ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
          .reduce(reduceSumFunc);

        var slope = ssXY / ssXX;
        var intercept = yBar - (xBar * slope);
        var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);

        return [slope, intercept, rSquare];
      }      
      
      function median(d) {
        return percentile(d, 0.5);
      }

      function percentile(d, target) {
        let data = d.slice(0);  // clone d
        data.sort(function(a, b){return a - b});
        let count = 0;
        for (val of data) {
          count += 1;
          if ((count / d.length) >= target)
            return val;
        }
        return -1;
      }

      function mean(d) {
        let sum = 0;
        for (val of d)
          sum += val;
        return sum / d.length;
      }

      function stripOutliers(d) {
        // An outlier is a point more than 1.5 IQR's below the first quartile
        // or above the third.
        let q1 = percentile(d, 0.25);
        let q3 = percentile(d, 0.75);
        let iqr = q3-q1;
        let min = q1 - iqr*1.5;
        let max = q3 + iqr*1.5;

        out = [];
        for (val of d) {
          if (val >= min && val <= max)
            out.push(val);
        }
        return out;
      }

      function stderr(d) {
        return standardDeviation(d) / Math.sqrt(d.length);
      }

      function stderrOfMedian(d) {
        return stderr(d) * 1.253
      }

    (async function() {
      for(let i = 0; i < kWarmUpCount; i++)
        await timeResourceLoad(1024 * 100); // warm up the network

      all_times = {}
      let x_data = []
      for (let exp = 0; exp < kMaxPow; exp++) {
        let bytes = 1024 * Math.pow(2, exp);
        x_data.push(bytes)
        let times = [];
        for (let attempt = 0; attempt < kSamplesPerSize; attempt++) {
          time = await timeResourceLoad(bytes);
          times.push(time);
        }
        all_times[bytes] = times;
      }

      let y_data = []
      let xy_data = []
      let y_error = []
      for(var key in all_times) {
        let d = stripOutliers(all_times[key])
        //let d = all_times[key]
        y_data.push(mean(d))
        xy_data.push([key, mean(d)])
        y_error.push(sampleStandardError(d))
       }

//       for(var key in all_times) {
//        let d = all_times[key]
      //         y_data.push(median(d))
//         xy_data.push([key, median(d)])
//         y_error.push(stderrOfMedian(d))
//       }

      let fitdata = leastSquares(x_data, y_data)
      let slope = fitdata[0]
      let y_intercept = fitdata[1]
//       console.log("xy_data " + xy_data);
//       let reg = regression('linear', xy_data);
//       let slope = reg.equation[0]
//       let y_intercept = reg.equation[1]
//       console.log("points = " + reg.points)
      // Plot the results
      let data =
        {
          x: x_data,
          y: y_data,
          error_y: {
            type: 'data',
            array: y_error,
            visible: true
          },
          type: 'scatter'
        }
      console.log("slope = " + slope);
      console.log("y_intercept = " + y_intercept)

      let y_fit = []
      for(i of x_data)
        y_fit.push(slope*i + y_intercept);

      let fit =
        {
          x: x_data,
          y: y_fit,
          type: 'line',
        }


      // for(var i = 0; i < x_data.length; i++) {
      //   bytes = x_data[i];
      //   var result = {
      //     type: 'scatter',
      //     y: mean(all_times[bytes]),
      //     name: x_data[i],
      //     // boxpoints: 'false',
      //     // jitter: 0.5,
      //     // whiskerwidth: 0.6,
      //     // fillcolor: 'cls',
      //     // boxmean: 'sd',
      //   }
      //   data.push(result)
      // }

      layout = {
          title: '',
          yaxis: {
              title: 'Time',
//               autorange: true,
//               showgrid: true,
//               zeroline: true,
//               dtick: 5,
//              gridcolor: 'rgb(255, 255, 255)',
//               gridwidth: 1,
//              zerolinecolor: 'rgb(255, 255, 255)',
//               zerolinewidth: 2
          },
          xaxis: {
            // type: 'log',
            autorange: true,
            title: 'Size in bytes'
          },
          // margin: {
          //     l: 40,
          //     r: 30,
          //     b: 80,
          //     t: 100
          // },
          paper_bgcolor: 'rgb(243, 243, 243)',
          plot_bgcolor: 'rgb(243, 243, 243)',
          showlegend: false
      };

      Plotly.newPlot('plot', [data, fit], layout);


    })();
</script>
</body>
</html>
